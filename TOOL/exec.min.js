const {
    sym_debug,
    ////
    noexist,
    ////
    TYPES,
    ERRORS,
    INFOS,
    TIPS,
    ////---------------state
    sym_state,         //getter
    sym_state_rdy        ,
    sym_state_conding    ,
    sym_state_open       ,
    sym_state_exec       ,
    sym_state_rs         ,
    sym_state_srj        ,
    sym_state_brj        ,
    sym_state_spause     ,
    sym_state_bpause     ,
    sym_state_im         ,
    ////--------------------completion
    sym_reject_origin,    //setter 当前停止在哪个nd ,用来recover(self_rejected)/continue(self_paused)
    sym_cond,            //setter conder 的结果
    sym_rslt,            //setter
    sym_exception,       //setter
    sym_psj,             //getter
    sym_renew_psj,
    ////-----------------------exec
    sym_rdy,           //软重启 非conding 非pending 状态可用
    sym_conding,
    sym_open,
    sym_exec,
    sym_rs,
    sym_srj,
    sym_brj,
    sym_spause,
    sym_bpause,
    sym_im,
    sym_respawn,
    sym_reset,          //硬重启 
    //sym_recv,           //getter setter
    //
    DFLT_CU_CONDER,
    DFLT_CU_EXECUTOR,
    DFLT_COPY,
    ////
    sym_if,
    sym_elif,
    sym_else,
    sym_while,
} = require("./const");



const Completion = require("./completion");

function _conder_rs(that) {
    if(!that.is_abandoned()) {
        that[sym_cond] = true;
        that[sym_open]();
    } else {
    }
}

function _conder_rj(that) {
    if(!that.is_abandoned()) {
        that[sym_cond] = false;
        let sdfs = that.$sdfs_;
        sdfs.forEach(nd=>nd[sym_state_im]()); //impossible 只需要设置状态
        _send_to_parent(that,sym_im); //父节点处理
    } else {
    }
}



function _add_to_running(that) {
    let rt = that.$root_;
    rt.running_.add(that);
}



function _send_to_parent(that,sig,data=noexist) {
     let parent = that.$parent_;
     DFLT_RECV(that,sig,parent,data);
}

function _delete_from_running(that) {
    let rt = that.$root_;
    rt.running_.delete(that);
    return(rt)
}


function _cycle(that) {
    let sdfs= that.$sdfs_;
    sdfs.forEach(nd=>nd[sym_reset](true));
    that[sym_conding]();
}

function _resolve(that,v,sig) {
    if(!that.is_abandoned()) {
        that[sym_state_rs]();
        that[sym_rslt] = v;
        if(that.$is_root()) {
            ////root 必须有promise
            that[sym_psj][1](v);
            _delete_from_running(that);
            if(that.conder_[sym_while]===true) {
                _cycle(that);
            } else {}
        } else if(that.is_serial() || that.is_parallel()) {
            if(that.is_promise_enabled()) {that[sym_psj][1](v)}
            _delete_from_running(that);
            if(that.conder_[sym_while]===true) {
                _cycle(that);
            } else {
                _send_to_parent(that,sig);
            }
        } else {
            ////不支持
        }
    } else {
        //abandoned
    }    
}

function _set_reject_state(that,sig) {
    if(sig === sym_srj) {
        that[sym_state_srj]();
    } else if(sig === sym_brj) {
        that[sym_state_brj]();
    } else {
    }
}

function _set_reject_origin_if_self_reject(rt,that,sig) {
    if(sig === sym_srj) {
        if(!rt.is_pending()) {
                'not update sym_reject_origin if not pending',
                'only update it on the first sym_srj',
                that,`when ${that.state_}`
            )
        } else {
            rt[sym_reject_origin] = that;
        }
    } else {}
}


function _reject(that,v,sig) {
    if(!that.is_abandoned()) {
        _set_reject_state(that,sig);
        that[sym_exception] = v;
        if(that.$is_root()) {
            ////root 必须有promise
            that[sym_psj][2](v);
            ////
            let rt = _delete_from_running(that);
            _set_reject_origin_if_self_reject(rt,that,sig);
            ////
        } else if(that.is_serial() || that.is_parallel()) {
            if(that.is_promise_enabled()) {that[sym_psj][2](v)}
            ////
            let rt = _delete_from_running(that);
            _set_reject_origin_if_self_reject(rt,that,sig);
            ////
            _send_to_parent(that,sig,v); //错误需要向上传播
        } else {
            ////不支持
        }
    } else {
        //abandoned
    }
}



function _serial_recv(src,sig,self,data) {
    if(self.is_opened()) {
        if(sig === sym_im) {
             if(src.$is_lstch()) {
                 self[sym_exec]();
             } else {
                 let rsib = src.$rsib_;
                 rsib[sym_conding]();
             }
        } else if(sig === sym_spause) {
            self[sym_bpause](data) //透传
        } else if(sig === sym_bpause) {
            self[sym_bpause](data) //透传
        } else if(sig === sym_rs) {
            if(src.$is_lstch()) {
                self[sym_exec](); //closing
            } else {
                let rsib = src.$rsib_;
                rsib[sym_conding]();
            }
        } else if(sig === sym_srj) {
            _reject(self,data,sym_brj);
        } else if(sig === sym_brj) {
            _reject(self,data,sym_brj);
        } else {
        }
    } else {
    }
}


function _get_children_stats(self) {
    let children = self.$children_;
    let total=children.length;
    let rs=0;
    let rj=0;
    let im=0;
    let rjchild;
    for(let child of children) {
        if(child.is_impossible()) {
            im = im+1;
        } else if(child.is_resolved()) {
            rs = rs+1
        } else if(child.is_rejected()) {
            rjchild = child
            rj = rj+1
        } else {
        }
    }
    return({total,rs,rj,im,rjchild})
}



function _parallel_recv(src,sig,self,data) {
    if(self.is_opened()) {
        if(sig === sym_im) {
             let {total,rs,rj,im,rjchild} = _get_children_stats(self)
             if(im>0) {
                 _reject(self,rjchild.exception_,sym_brj);
             } else if(total === rs+im) {
                 self[sym_exec]();
             } else {
             }
        } else if(sig === sym_spause) {
            self[sym_bpause](data) //透传
        } else if(sig === sym_bpause) {
            self[sym_bpause](data) //透传
        } else if(sig === sym_rs) {
            let {total,rs,rj,im,rjchild} = _get_children_stats(self);
            if(rj>0) {
                let rt = self.$root_;
                rt[sym_reject_origin] = rjchild;       
                _reject(self,rjchild.exception_,sym_brj);
            } else if(total === rs+im) {
                self[sym_exec]();   //closing
            } else {
            }
        } else if(sig === sym_srj) {
            _reject(self,data,sym_brj);
        } else if(sig === sym_brj) {
            _reject(self,data,sym_brj);
        } else {
        }
    } else if(self.is_bubble_rejected()) {
    } else if(self.is_bubble_paused()) {
    } else {
    }
}


const DFLT_RECV = (src,sig,self,data) => {
    if(self.is_serial()) {
        _serial_recv(src,sig,self,data);
    } else {
        _parallel_recv(src,sig,self,data);
    }
}



class Exec extends Completion {
     #conder = DFLT_CU_CONDER
     #exec   = DFLT_CU_EXECUTOR
     ////
     get conder_()                 {return(this.#conder)}
     set conder_(f)                {
         let pnd = this.$parent_;
         if(pnd === null) {
             this.#conder=f
         } else {
             if(pnd.is_serial()) {
                 this.#conder=f
             } else {
                 if(this.is_conder_elif() || this.is_conder_else()) {
                     console.log(TIPS.parallel_child_cant_use_elif_or_else)
                 } else {
                     this.#conder=f
                 }
             }
         }
     }
     is_conder_if()                {return(this.#conder[sym_if]===true)}
     is_conder_elif()              {return(this.#conder[sym_elif]===true)}
     is_conder_else()              {return(this.#conder[sym_else]===true)}
     is_conder_while()             {return(this.#conder[sym_while]===true)}
     get if_head_()                {
          let lsib = this
          while(lsib !== null) {
              if(lsib.is_conder_if()) {
                  return(lsib)
              } else {
                  lsib = lsib.$lsib_
              }
          }
          return(lsib)
     }
     is_all_if_chain_psib_conder_failed() {
         let lsib = this.$lsib_;
         while(lsib !== null) {
             if(lsib.is_conder_if()) {
                if(lsib.cond_ === true) {
                    return(false)
                } else {
                    return(true)
                }
             } else if(lsib.is_conder_elif()) {
                 if(lsib.cond_ === true) {
                     return(false)
                 } else {}
             } else {
                 return(true)
             }
             lsib = lsib.$lsib_
         }
         return(true)
     }
     ////
     get executor_()               {return(this.#exec)}
     set executor_(f)              {this.#exec=f}
     ////
     is_abandoned()                {return(this.$forest_===null)}
     ////
     [sym_conding]() {
         this[sym_state_conding]();
         let conder_executor = this.#conder;
         conder_executor(()=>{_conder_rs(this)},()=>{_conder_rj(this)},this)
     }
     [sym_open]() {
         //一定是conder 结果为true
         this[sym_state_open]();   //设置状态为opened
         if(this.$is_leaf()) {
             this[sym_exec]();
         } else if(this.is_serial()) {
             let fstch = this.$fstch_;
             fstch[sym_conding]();
         } else if(this.is_parallel()) {
             let children = this.$children_;
             children.forEach(chnd=>chnd[sym_conding]());
         } else {
         }
    }
    [sym_exec]() {
        this[sym_state_exec]();
        _add_to_running(this);
        let executor = this.#exec;
        let resolve = (v)=>{    _resolve(this,v,sym_rs)}
        let reject  = (v)=>{     _reject(this,v,sym_srj)}
        executor(resolve,reject,this);
    }
    [sym_spause](copy_func=DFLT_COPY) {
        if(this.is_self_executing()) {
            let nthis = this[sym_respawn](true,copy_func);  //复制,running delete 动作在respawn种完成
            nthis[sym_state_spause]();
            if(nthis.$parent_ !== null) {
                _send_to_parent(nthis,sym_spause,nthis);
            } else {
            }
        } else {
        }
    }
    [sym_bpause](spause_src) {
        //不能直接调用,只能在recv中调用
        if(this.is_opened()) {
            this[sym_state_bpause]();
            if(this.$parent_ !== null) {
                _send_to_parent(this,sym_bpause,spause_src);
            } else {
            }
        } else {
        }
    }
    [sym_respawn](copy=true,copy_func=DFLT_COPY) {
        let forest = this.$forest_;
        let nnd =  forest.node(this.constructor);
        nnd.name_     = this.name_; 
        nnd.conder_   = this.conder_;
        nnd.executor_ = this.executor_;
        nnd[sym_renew_psj]();
        ////
        let rt = this.$root_;
        let in_running = rt.running_.has(this);
        ////
        this.$replace_node(nnd);
        ////now this is disconnected
        if(in_running){
            rt.running_.add(nnd);
            rt.running_.delete(this);
        } else {}
        ////
        if(rt.rejected_at_ === this) {
             rt[sym_reject_origin] = nnd;
        } else {}
        ////
        if(copy) {
            copy_func(nnd,this);
        } else {}
        ////
        this.$erase();
        return(nnd)
    }
    [sym_rdy](clear_cond=false,renew_psj=true) {
        //soft  不可用于 conding self_executing paused 
        if(renew_psj) {
            //bpause 不renew_psj
            this[sym_renew_psj]();
        } else {}
        if(clear_cond) {
            this[sym_cond] = noexist
        } else {}
        this[sym_rslt] = noexist;
        this[sym_exception] = noexist;
        ////
        let rt = this.$root_;
        rt.running_.delete(this);
        if(rt.rejected_at_ === this) {
             rt[sym_reject_origin] = noexist;
        } else {}
        ////
        this[sym_state_rdy]();
    }
    [sym_reset](copy_func=DFLT_COPY) {
        //判断状态
        if(this.is_conding() || this.is_self_executing()) {
            let nthis = this[sym_respawn](true,copy_func);
            _delete_from_running(nthis);
        } else {
            this[sym_rdy](true,true);
        }
    }
    ////
}

module.exports = Exec; 

